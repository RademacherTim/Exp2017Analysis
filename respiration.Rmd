---
title: "Estimating respiratory losses (SI 3)"
author: Tim Rademacher
date: "09/09/2019"
output: html_document
bibliography: "/home/trademacehr/projects/PlantGrowth/bib/Exp2017.bib"
csl: "/home/trademacehr/projects/PlantGrowth/bib/harvard.csl"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library ('tidyverse')
library ('readxl')
library ('lubridate')
library ('googledrive')

# set colour scheme for control, girdled, compressed, double compressed and chilled
colours <- c ('#91b9a4','#C0334D','#F18904','#5C4A72','#23345C')
```

## Estimating respiratory losses for stem sections

To estimate stem respiratory losses, weekly stem respiration measurements were made using a Li-Cor820 starting at 13.00h. The LiCor820 was attached to a PVC pipe (4" diameter) that were previously fitted and attached to the stem sections using silicone to create a closed chamber in which the enclosed air circulates via a small pump, similar to the Flux Puppy system [@carbone_flux_2019]. Respiration rates were calculate from the change CO<sub>2</sub> using the RespChamberProc package [@citation] in R [@r_core_team_r:_2018]. Stem sections were measured in the same order to minimise variations in time of day from week to week. The rates were corrected for water vapour pressure fluctuations using climate data from Fisher weather station for the 15 minute interval during which the measurement took place. 

## Integration over the surface area of the stem section

Instantaneous fluxes of respiratory CO2 loss were measured as described above and subsequently integrated across space (e.g. the specific surface area of a 10 cm stem section) for each stem section to estimate the respiratrates in grams per stem section per day. To integrate the measured respiration rates across a 10cm stem section, we calculate the surface area of the i-th stem section ($A_{s,i}$) as follows:

$$
A_{s, i} = \frac {cbh_{s,i}} {100} \times h 
$$
, where is the $cbh_{s,i}$ is the circumference in cemtimeters and $h$ is the height of the section in meters (here $h = 0.1$m).

The stem respiration rate over this surface area was then determined by multiplication of the instanteanous respiration flux (in $g \, m^{-2} \,day^{-1}$) by the surface area to get the respiration rate (in $g \, day_{-1}$).
```{r integrateAcrossSpace}
# Get the tree measurements of circumference from spreadsheet
allometricData <- read_excel (path = '/media/TREE/PlantGrowth/data/allometry/allometricDataExp2017.xlsx', 
                              sheet = 'allometricData', 
                              na = "NA")

# Define height of the section (h; in m)
h <- 0.1
# create a tibble with the responseVariables
if (!exists ('responseVariables')) {
  responseVariables <- tibble (year = 2017,
                               month    = c (rep (7, 41), rep (8, 41),
                                             rep (10, 41), rep (11, 41)),
                               tree = rep (1:41, 4),
                               resp250 = NA, resp200 = NA, resp150 = NA,	resp100 = NA,
                               resp50 = NA, A250 = NA, A200 = NA, A150 = NA, A100 = NA,
                               A50 = NA)
} else {
  if ("resp150" %in% colnames (responseVariables)) { 
    responseVariables <- responseVariables %>% select (-c (resp50, resp100, resp150, resp200, resp250, A250, A200, A150, A100, A50)) 
  }
  responseVariables <-  add_column (responseVariables, resp250 = NA, resp200 = NA,
                                    resp150 = NA,	resp100 = NA, resp50 = NA, A250 = NA, 
                                    A200 = NA, A150 = NA, A100 = NA, A50 = NA)
}
# Loop over each tree create surface area for each section
for (r in 1:dim (responseVariables) [1]) {
  iTree <- responseVariables [['tree']] [r]
  
  # Check whether this tree has only one chamber (i.e. control group)
  if (allometricData [['treatment']] [allometricData [['tree']] == iTree] == 1) {
    responseVariables [['A150']] [r] <- 
      allometricData [['cbh150']] [allometricData [['tree']] == iTree] / 100.0 * h

  # Check whether this tree has two chambers (i.e. gridled or single compression)
  } else if (allometricData [['treatment']] [allometricData [['tree']] == iTree] == 2 | 
             allometricData [['treatment']] [allometricData [['tree']] == iTree] == 3) {
    responseVariables [['A100']] [r] <- 
      allometricData [['cbh100']] [allometricData [['tree']] == iTree] / 100.0 * h
    responseVariables [['A200']] [r] <- 
      allometricData [['cbh200']] [allometricData [['tree']] == iTree] / 100.0 * h

  # Check whether this tree has three chambers (i.e. double compression)
  } else if (allometricData [['treatment']] [allometricData [['tree']] == iTree] == 4) {
    responseVariables [['A50']]  [r] <- 
      allometricData [['cbh50']]  [allometricData [['tree']] == iTree] / 100.0 * h
    responseVariables [['A150']] [r] <- 
      allometricData [['cbh150']] [allometricData [['tree']] == iTree] / 100.0 * h
    responseVariables [['A250']] [r] <- 
      allometricData [['cbh250']] [allometricData [['tree']] == iTree] / 100.0 * h
  }
}

# Read 2017 respiration rates derived using RespChamberProc package.
respRates2017 <- read_csv ('../data/resp_compression_2017_11_01.csv',      
                           col_types = cols ())
respRates2017 <- respRates2017 [-1, ]

# Integrate the respiration rate over space 
respRates2017 <- add_column (respRates2017, flux_g_day = NA)
for (iTree in 1:41) {
  # Check whether this tree has only one chamber (i.e. control group)
  if (allometricData [['treatment']] [allometricData [['tree']] == iTree] == 1) {
    respRates2017 [['flux_g_day']] [respRates2017 [['tree']] == iTree] <- respRates2017 [['flux_g']] [respRates2017 [['tree']] == iTree] * unique (responseVariables [['A150']] [responseVariables [['tree']] == iTree])
  } else if (allometricData [['treatment']] [allometricData [['tree']] == iTree] == 2 |
             allometricData [['treatment']] [allometricData [['tree']] == iTree] == 3) {
    condition <- respRates2017 [['tree']] == iTree & respRates2017 [['chamber']] == 1
    respRates2017 [['flux_g_day']] [condition] <- 
      respRates2017 [['flux_g']] [condition] * 
      unique (responseVariables [['A100']] [responseVariables [['tree']] == iTree])

    condition <- respRates2017 [['tree']] == iTree & respRates2017 [['chamber']] == 2
    respRates2017 [['flux_g_day']] [condition] <- 
      respRates2017 [['flux_g']] [condition] * 
      unique (responseVariables [['A200']] [responseVariables [['tree']] == iTree])
  } else if (allometricData [['treatment']] [allometricData [['tree']] == iTree] == 4) {
    condition <- respRates2017 [['tree']] == iTree & respRates2017 [['chamber']] == 1
    respRates2017 [['flux_g_day']] [condition] <- 
      respRates2017 [['flux_g']] [condition] * 
      unique (responseVariables [['A50']] [responseVariables [['tree']] == iTree])
    condition <- respRates2017 [['tree']] == iTree & respRates2017 [['chamber']] == 2
    respRates2017 [['flux_g_day']] [condition] <- 
      respRates2017 [['flux_g']] [condition] * 
      unique (responseVariables [['A150']] [responseVariables [['tree']] == iTree])
    condition <- respRates2017 [['tree']] == iTree & respRates2017 [['chamber']] == 3
    respRates2017 [['flux_g_day']] [condition] <- 
      respRates2017 [['flux_g']] [condition] * 
      unique (responseVariables [['A250']] [responseVariables [['tree']] == iTree])
  }
}

```

# Integrate across time

Respiration rates were averaged for over four time period: (i) pre-treatment, (ii) treatment period 1 (i.e. first month after start of the experiment), (iii) treament period 2 (i.e. second and third month after the start of the experiment) and (iii) treatment period 3 (i.e. fourth month after the start of the experiment to the end of the growing season). 

We then approximated the total loss of carbon for each combination of period $j$ and stem section $i$ ($R_{i,j}$) by multiplying the temporal mean of spatially integrated respiration rates in $g \, day^{-1}$ measured during each period $j$ by the length of the period ($l_p$ in days).

$$
R_{i,j} = \frac {1} {n} \sum_{k=1}^{n} R_{i,k} \times l_p
$$
, where n is the number of weekly sampling dates during each period.

``` {r temporalIntegration}
# Set period boundaries
boundaries <- as.POSIXct (c ('2017-07-05','2017-08-10','2017-10-09','2017-11-01'), tz = 'EST')

# Calculate the geometric mean for each period for each stem section
for (period in 1:4) {
  if (period == 1) {
    periodData <- filter (respRates2017, respRates2017 [['date']] <= boundaries [period])
    pLen <- boundaries [period] - as.POSIXct (min (periodData [['date']]), tz = 'EST')
  } else if (period > 1 & period < 5) {
    periodData <- filter (respRates2017, respRates2017 [['date']] > boundaries [period-1] &
                                         respRates2017 [['date']] <= boundaries [period])
    pLen <- boundaries [period] - boundaries [period-1]
  } else {
    periodData <- filter (respRates2017, respRates2017$date >  boundaries [period])
    pLen <- as.POSIXct (max (periodData$date, na.rm = T), tz = 'EST') - boundaries [period]
  }
  
  # Aggregate the mean respiration over each period by chamber and tree (g day-1)
  tmpResp <- periodData %>% 
    group_by (tree, chamber) %>% 
    summarize (meanResp = mean (flux_g_day, na.rm = T))
  
  # Add a period column to temporary tibble
  tmpResp$period <- period
  
  # Multiply mean respiration rate by length of period to get the total respiratory carbon loss (g period-1)
  tmpResp$totalResp <- tmpResp$meanResp * as.numeric (pLen, 'days')
  
  # Add the period specific data to the responseVariables tibble
  for (iTree in 1:41){
    condition <- responseVariables [['month']] == month (boundaries [period]) &
                 responseVariables [['tree']]  == iTree
    if (allometricData [['treatment']] [iTree] == 1) {
      responseVariables [['resp150']] [condition] <- tmpResp [['totalResp']] [tmpResp [['tree']] == iTree] 
    } else if (allometricData [['treatment']] [iTree] == 2 | 
               allometricData [['treatment']] [iTree] == 3) {
      responseVariables [['resp100']] [condition] <- 
        tmpResp [['totalResp']] [tmpResp [['tree']] == iTree & tmpResp [['chamber']] == 1]
      responseVariables [['resp200']] [condition] <- 
        tmpResp [['totalResp']] [tmpResp [['tree']] == iTree & tmpResp [['chamber']] == 2]
    } else if (allometricData [['treatment']] [iTree] == 4) {
      responseVariables [['resp50']]  [condition] <- 
        tmpResp [['totalResp']] [tmpResp [['tree']] == iTree & tmpResp [['chamber']] == 1]
      responseVariables [['resp150']] [condition] <- 
        tmpResp [['totalResp']] [tmpResp [['tree']] == iTree & tmpResp [['chamber']] == 2]
      responseVariables [['resp250']] [condition] <- 
        tmpResp [['totalResp']] [tmpResp [['tree']] == iTree & tmpResp [['chamber']] == 3]
    } 
  }
}
```


``` {r plotResp}
# add treatments to the responseVariables
responseVariables <- add_column (responseVariables, treatment = rep (allometricData [['treatment']], 4))

# calculate mean
suppressWarnings (tmp50  <- responseVariables %>% group_by (month, treatment) %>% summarise (mean = mean (resp50, na.rm = T), min = min (resp50, na.rm = T), max = max (resp50, na.rm = T)))
suppressWarnings (tmp100 <- responseVariables %>% group_by (month, treatment) %>% summarise (mean = mean (resp100, na.rm = T), min = min (resp100, na.rm = T), max = max (resp100, na.rm = T)))
suppressWarnings (tmp150 <- responseVariables %>% group_by (month, treatment) %>% summarise (mean = mean (resp150, na.rm = T), min = min (resp150, na.rm = T), max = max (resp150, na.rm = T)))
suppressWarnings (tmp200 <- responseVariables %>% group_by (month, treatment) %>% summarise (mean = mean (resp200, na.rm = T), min = min (resp200, na.rm = T), max = max (resp200, na.rm = T)))
suppressWarnings (tmp250 <- responseVariables %>% group_by (month, treatment) %>% summarise (mean = mean (resp250, na.rm = T), min = min (resp250, na.rm = T), max = max (resp250, na.rm = T)))

par (mfrow = c (2, 2))
par (mar = c (5,5,1,1))
plot (x = tmp150 [['month']] [tmp150 [['treatment']] == 1],
      y = tmp150 [['mean']] [tmp150 [['treatment']] == 1],
      xlab = 'month', ylab  = 'respiratory loss (gC)', las = 1,
      typ = 'l', lwd = 2,
      col = colours [1],
      ylim =  c (0, 30))
polygon (x = c (tmp150 [['month']] [tmp150 [['treatment']] == 1], 
                rev (tmp150 [['month']] [tmp150 [['treatment']] == 1])),
        y = c (tmp150 [['max']] [tmp150 [['treatment']] == 1], 
               rev (tmp150 [['min']] [tmp150 [['treatment']] == 1])),
        col = '#91b9a433', lty = 0)
plot (x = tmp100 [['month']] [tmp100 [['treatment']] == 2],
       y = tmp100 [['mean']]  [tmp100 [['treatment']] == 2],
      xlab = 'month', ylab  = 'respiratory loss (gC)', las = 1,
      typ = 'l', lwd = 2, lty = 2,
      col = colours [2],
      ylim =  c (0, 30))
polygon (x = c (tmp100 [['month']] [tmp100 [['treatment']] == 2], 
                rev (tmp100 [['month']] [tmp100 [['treatment']] == 2])),
        y = c (tmp100 [['max']] [tmp100 [['treatment']] == 2], 
               rev (tmp100 [['min']] [tmp100 [['treatment']] == 2])),
        col = '#C0334D33', lty = 0)
lines (x = tmp200 [['month']] [tmp200 [['treatment']] == 2],
       y = tmp200 [['mean']]  [tmp200 [['treatment']] == 2],
       lty = 1, lwd = 2, col = colours [2])
polygon (x = c (tmp200 [['month']] [tmp200 [['treatment']] == 2], 
                rev (tmp200 [['month']] [tmp200 [['treatment']] == 2])),
        y = c (tmp200 [['max']] [tmp200 [['treatment']] == 2], 
               rev (tmp200 [['min']] [tmp200 [['treatment']] == 2])),
        col = '#C0334D33', lty = 0)
plot (x = tmp100 [['month']] [tmp100 [['treatment']] == 3],
       y = tmp100 [['mean']]  [tmp100 [['treatment']] == 3],
      xlab = 'month', ylab  = 'respiratory loss (gC)', las = 1,
      typ = 'l', lwd = 2, lty = 2,
      col = colours [3],
      ylim =  c (0, 30))
polygon (x = c (tmp100 [['month']] [tmp100 [['treatment']] == 3], 
                rev (tmp100 [['month']] [tmp100 [['treatment']] == 3])),
        y = c (tmp100 [['max']] [tmp100 [['treatment']] == 3], 
               rev (tmp100 [['min']] [tmp100 [['treatment']] == 3])),
        col = '#F1890433', lty = 0)
lines (x = tmp200 [['month']] [tmp200 [['treatment']] == 3],
       y = tmp200 [['mean']]  [tmp200 [['treatment']] == 3],
       lty = 1, lwd = 2, col = colours [3])
polygon (x = c (tmp200 [['month']] [tmp200 [['treatment']] == 3], 
                rev (tmp200 [['month']] [tmp200 [['treatment']] == 3])),
        y = c (tmp200 [['max']] [tmp200 [['treatment']] == 3], 
               rev (tmp200 [['min']] [tmp200 [['treatment']] == 3])),
        col = '#F1890433', lty = 0)
plot (x = tmp50 [['month']] [tmp50 [['treatment']] == 4],
       y = tmp50 [['mean']]  [tmp50 [['treatment']] == 4],
      xlab = 'month', ylab  = 'respiratory loss (gC)', las = 1,
      typ = 'l', lwd = 2, lty = 2,
      col = colours [4],
      ylim =  c (0, 30))
polygon (x = c (tmp50 [['month']] [tmp50 [['treatment']] == 4], 
                rev (tmp50 [['month']] [tmp50 [['treatment']] == 4])),
        y = c (tmp50 [['max']] [tmp50 [['treatment']] == 4], 
               rev (tmp50 [['min']] [tmp50 [['treatment']] == 4])),
        col = '#5C4A7233', lty = 0)
lines (x = tmp150 [['month']] [tmp150 [['treatment']] == 4],
       y = tmp150 [['mean']]  [tmp150 [['treatment']] == 4],
      col = colours [4], lwd = 2, lty = 3)
polygon (x = c (tmp150 [['month']] [tmp150 [['treatment']] == 4], 
                rev (tmp150 [['month']] [tmp150 [['treatment']] == 4])),
        y = c (tmp150 [['max']] [tmp150 [['treatment']] == 4], 
               rev (tmp150 [['min']] [tmp150 [['treatment']] == 4])),
        col = '#5C4A7233', lty = 0)
lines (x = tmp250 [['month']] [tmp250 [['treatment']] == 4],
       y = tmp250 [['mean']]  [tmp250 [['treatment']] == 4],
      col = colours [4], lwd = 2, lty = 1)
polygon (x = c (tmp250 [['month']] [tmp250 [['treatment']] == 4], 
                rev (tmp150 [['month']] [tmp250 [['treatment']] == 4])),
        y = c (tmp250 [['max']] [tmp250 [['treatment']] == 4], 
               rev (tmp250 [['min']] [tmp250 [['treatment']] == 4])),
        col = '#5C4A7233', lty = 0)
```

### To-do list and comments
- add the 2018 data and therefore a fifth period.

# References